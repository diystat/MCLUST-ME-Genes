

library(MASS)

## simulate well-separated clusters, with correct membership as initial membership matrix:  
sim = function(s){
  # set sample size
  nvec = c(3,3,4) * 5
  n = sum(nvec)
  p = 2
  
  set.seed(0)
  mu1 = c(1,1)
  mu2 = c(4,-4)
  mu3 = c(-9,9)
  
  err = array(0, dim=c(p,p,n))  
  for(i in 1:n){
    err[,,i] = matrix(0,p,p)
    diag(err[,,i]) = 0
  }
  
  sigma1 = matrix(c(1,0,0,1),nrow=2)
  sigma2 = matrix(c(2,0,0,2),nrow=2)
  sigma3 = matrix(c(3,0,0,3),nrow=2)
  
  s1 = mvrnorm(nvec[1], mu1, (sigma1+err[,,1]))
  s2 = mvrnorm(nvec[2], mu2, (sigma2+err[,,1]))
  s3 = mvrnorm(nvec[3], mu3, (sigma3+err[,,1]))
  
  # membership matrix:
  temp = c(rep(c(1,0,0),nvec[1]),rep(c(0,1,0),nvec[2]),rep(c(0,0,1),nvec[3]))
  z.true = matrix(temp, nrow=n, byrow=TRUE)
  
  samp = rbind(s1,s2,s3)
  
  plot(s1,xlim=c(-4,4),ylim=c(-4,4))
  points(s2, col="blue")
  points(s3, col="red")
  
  z.ini = z.true
  
  ptm1 = proc.time()
  my.result = ME.VVV.err(samp, z.ini, err)
  proc.time() - ptm1
  
  meVVV(samp,z.ini)
  
  
  
  # "bad" initial:
  temp2 = c(rep(c(0,1,0),nvec[1]),rep(c(0,0,1),nvec[2]),rep(c(1,0,0),nvec[3]))
  z.badini = matrix(temp2, nrow=n, byrow=TRUE)
 
  ME.VVV.err(samp, z.badini, err)
  
  
  
  # initial classification generated by hc from package mclust
  G = 3 # number of clusters
  
  ## obtain an initial classification, using hierarchical clustering:
  hctree = hc("VVV", samp)
  temp = as.numeric(hclass(hctree, G))
  
  ini.class = matrix(0, n, G)
  for(i in 1:n){
    g = temp[i]
    ini.class[i,g] = 1
  }
  
  my.result = ME.VVV.err(samp, ini.class, err)

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}
  
  
  

 
  
  