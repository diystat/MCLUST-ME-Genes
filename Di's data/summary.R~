library(NBPSeq);
library(MASS);

## File names
file.nb.data = "../data/2014-01-29_normalized.nb.data.Rdata";
file.design = "../data/2014-01-30_design.Rdata";
file.nb.glm = "../data/2014-05-06.nb.glm.Rdata";

compute.variance = function() {
  ## 2014-05-07
  rm(list=ls());
  source("nb.glm.1u.R");

  ## Load NB data
  print(load(file.nb.data));
  class(nb.data) = "nb.data";
  print(nb.data);
  m = nrow(nb.data$counts);
  n = ncol(nb.data$counts);
 
  ## Load design
  print(load(file.design));

  ## In this model, the first 5 columns of the regression coefficients
  ## correspond to fold changes. The dispersion was unknown.
  print(load(file.nb.glm));

  ## See the structure of fitted full model
  str(full);

  ## The model matrix used to fit NB regression model: the first 5
  ## columns correspond the log fold changes at 5 time points and last
  ## 6 columns correspond to the mean expression levels at each time
  ## point
  p = 11;
  x = matrix(0, n, p);
  x[,6:11] = model.matrix(~0+ factor(hpi));
  v = rep(c(-0.5, 0.5), each=3); 
  for(i in 1:5) {
    x[(4:9) + (i-1)*6, i] = v;
  }
  
  ## Compute variance from the observed information matrix
    
  ## Compare there ways to compute the CI:  inverse, generalized
  ## inverse, and inverting the diaganoal elements

  ## Filter rows with all zeros
  ss = (1:m)[rowSums(nb.data$counts)>0];
  length(ss);

  ## Compute the variance-covariance matrix and sd of the first five
  ## regression coefficients (corresponding to log fold changes at five
  ## time points). The first method is correct.
  v1 = array(NA, c(5, 5, m));
  v2 = array(NA, c(5, 5, m));

  sd1 = matrix(NA, m, 5);
  sd2 = matrix(NA, m, 5);

  ## DEBUG: when i = 12, some beta.hat tend to -Inf.
  for (i in ss[1:100]) {
  ## for (i in ss) {
    j = full$j[,,i];
    v1[,,i] = ginv(j)[-1,-1][1:5, 1:5];
    sd1[i,] = sqrt(diag(v1[,,i]));
  }

  ## If we treat the estimated dispersion as known, the observed info is always diaganol?
  ## Yes for the log fold changes.
  for (i in ss[1:100]) {
  ## for (i in ss[1:100]) {
    j = full$j[,,i];
    v2[,,i] = solve(j[-1,-1])[1:5,1:5];
    sd2[i,] = sqrt(diag(v2[,,i]));
  }

  ## range(sd2-sd1, na.rm=TRUE);

  "Done."
}

## Find top genes using LR test
find.top.genes = function() {
  ## 2014-05-08
  rm(list=ls());
  source("nb.glm.1u.R");

  ## Load NB data
  print(load(file.nb.data));
  class(nb.data) = "nb.data";
  print(nb.data);

  ## Load design
  print(load(file.design));

  ## In this model, the first 5 columns of the regression coefficients
  ## correspond to fold changes. The dispersion was unknown.
  print(load(file.nb.glm));

  ## In this model, each column of the regression coefficient
  ## correspond to one group. The dipsersion was estimated from a NBQ
  ## model.
  ## 
  ## print(load(file.group.model));

  ##
  t = 2 * (full$l - reduced$l);

  ##
  filter = apply(full$mu>1, 1, all);
  t[!filter] = NA;

  ## The type-I error is inflated
  p = pchisq(t, 5, lower.tail=FALSE);
  hist(p);

  ##
  or = order(-t);
  top = or[1:500];

  id = apply(full$mu > 1, 1, all);

  par(mfrow=c(2, 3));
  ## MA plots at five time points
  xlabs = c("10 min", "1 hr", "3 hr", "6 hr", "12 hr");
  for (i in 1:5) {
    smart.plot(full$beta[id,i+6]/log(10), full$beta[id,i]/log(2), pch=19, clip=32,
               xlab = xlabs[i],
               ylab = "log (base 2) fold change" 
               );
    smart.points(full$beta[top,i+6]/log(10), full$beta[top,i]/log(2), col="cyan");
  }

  ## matplot
  x = c(1/6, 1, 3, 6, 12);
  top = or[1:10];
  matplot(x, t(full$beta[top, 1:5]), type="l", col=1);

  ##
  require(ggplot2)
  par(mfrow=c(2,5));
  top = or[2:11];

  for (i in top) {

    ## i = top[2];
    v = solve(full$j[, , i])[-1,-1][1:5,1:5];
    sd = sqrt(diag(v));

    y = full$beta[i,1:5];
    L = y - sd * 2;
    U = y + sd * 2;
    matplot(x , cbind(L, y, U), type=c("l", "b", "l"), pch=1, lty=c(2, 1, 2), col=1);

    if (FALSE) {
      matpoints(x , cbind(L, U));

      graphics.off();

      ggplot(df, aes(x = x, y = y)) +
        geom_point(size = 4) +
          geom_errorbar(aes(ymax = U, ymin = L))
    }
  }



}


  

